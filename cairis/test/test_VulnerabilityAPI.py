# -*- coding: utf-8 -*-
#  Licensed to the Apache Software Foundation (ASF) under one
#  or more contributor license agreements.  See the NOTICE file
#  distributed with this work for additional information
#  regarding copyright ownership.  The ASF licenses this file
#  to you under the Apache License, Version 2.0 (the
#  "License"); you may not use this file except in compliance
#  with the License.  You may obtain a copy of the License at
#
#  http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing,
#  software distributed under the License is distributed on an
#  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
#  KIND, either express or implied.  See the License for the
#  specific language governing permissions and limitations
#  under the License.


import logging
import sys

if sys.version_info > (3,):
    from urllib.parse import quote
else:
    from urllib import quote
import jsonpickle
from cairis.core.Vulnerability import Vulnerability
from cairis.core.VulnerabilityEnvironmentProperties import (
    VulnerabilityEnvironmentProperties,
)
from cairis.test.CairisDaemonTestCase import CairisDaemonTestCase
import os
from cairis.mio.ModelImport import importModelFile

__author__ = "Robin Quetin, Shamal Faily"


class VulnerabilityAPITests(CairisDaemonTestCase):
    @classmethod
    def setUpClass(cls):
        importModelFile(
            os.environ["CAIRIS_SRC"] + "/../examples/exemplars/NeuroGrid/NeuroGrid.xml",
            1,
            "test",
        )

    def setUp(self):
        self.logger = logging.getLogger(__name__)
        self.existing_vulnerability_name = "Replay vulnerability"
        self.existing_environment_name = "Stroke"
        self.existing_asset_names = ["Clinical data", "Data node"]
        self.vulnerability_class = (
            Vulnerability.__module__ + "." + Vulnerability.__name__
        )

    def test_get_all(self):
        method = "test_get_all"
        rv = self.app.get("/api/vulnerabilities?session_id=test")
        if sys.version_info > (3,):
            responseData = rv.data.decode("utf-8")
        else:
            responseData = rv.data
        vulnerabilities = jsonpickle.decode(responseData)
        self.assertIsNotNone(vulnerabilities, "No results after deserialization")
        self.assertIsInstance(
            vulnerabilities, list, "The result is not a list as expected"
        )
        self.assertGreater(
            len(vulnerabilities), 0, "No vulnerabilities in the dictionary"
        )
        self.logger.info("[%s] Vulnerabilities found: %d", method, len(vulnerabilities))
        vulnerability = vulnerabilities[0]
        self.logger.info(
            "[%s] First vulnerability: %s\n", method, vulnerability["theName"]
        )

    def test_get_by_name(self):
        method = "test_get_by_name"
        url = "/api/vulnerabilities/name/%s?session_id=test" % quote(
            self.existing_vulnerability_name
        )
        rv = self.app.get(url)
        self.assertIsNotNone(rv.data, "No response")
        if sys.version_info > (3,):
            responseData = rv.data.decode("utf-8")
        else:
            responseData = rv.data
        self.logger.debug("[%s] Response data: %s", method, responseData)
        vulnerability = jsonpickle.decode(responseData)
        self.assertIsNotNone(vulnerability, "No results after deserialization")
        self.logger.info("[%s] Vulnerability: %s\n", method, vulnerability["theName"])

    def test_delete(self):
        method = "test_delete"
        url = "/api/vulnerabilities/name/%s?session_id=test" % quote(
            self.prepare_new_vulnerability().theName
        )
        new_vulnerability_body = self.prepare_json()

        self.app.delete(url)
        self.logger.info("[%s] Object to delete: %s", method, new_vulnerability_body)
        self.app.post(
            "/api/vulnerabilities",
            content_type="application/json",
            data=new_vulnerability_body,
        )
        self.logger.info("[%s] URL: %s", method, url)
        rv = self.app.delete(url)
        if sys.version_info > (3,):
            responseData = rv.data.decode("utf-8")
        else:
            responseData = rv.data
        self.logger.info("[%s] Response data: %s", method, responseData)
        self.assertIsNotNone(responseData, "No response")
        json_resp = jsonpickle.decode(responseData)
        self.assertIsInstance(
            json_resp, dict, "The response cannot be converted to a dictionary"
        )
        message = json_resp.get("message", None)
        self.assertIsNotNone(message, "No message in response")
        self.logger.info("[%s] Message: %s\n", method, message)

    def test_post(self):
        method = "test_post"
        url = "/api/vulnerabilities"
        self.logger.info("[%s] URL: %s", method, url)
        new_vulnerability_body = self.prepare_json()
        self.app.delete(
            "/api/vulnerabilities/name/%s?session_id=test"
            % quote(self.prepare_new_vulnerability().theName)
        )
        rv = self.app.post(
            url, content_type="application/json", data=new_vulnerability_body
        )
        if sys.version_info > (3,):
            responseData = rv.data.decode("utf-8")
        else:
            responseData = rv.data
        self.logger.debug("[%s] Response data: %s", method, responseData)
        json_resp = jsonpickle.decode(responseData)
        self.assertIsNotNone(json_resp, "No results after deserialization")
        msg = json_resp.get("message", None)
        self.assertIsNotNone(msg, "No message returned")
        self.logger.info("[%s] Message: %s\n", method, msg)
        rv = self.app.delete(
            "/api/vulnerabilities/name/%s?session_id=test"
            % quote(self.prepare_new_vulnerability().theName)
        )

    def test_put(self):
        method = "test_put"
        url = "/api/vulnerabilities"
        self.logger.info("[%s] URL: %s", method, url)
        new_vulnerability_body = self.prepare_json()

        rv = self.app.delete(
            "/api/vulnerabilities/name/%s?session_id=test"
            % quote(self.prepare_new_vulnerability().theName)
        )
        rv = self.app.post(
            url, content_type="application/json", data=new_vulnerability_body
        )
        if sys.version_info > (3,):
            responseData = rv.data.decode("utf-8")
        else:
            responseData = rv.data
        self.logger.debug("[%s] Response data: %s", method, responseData)
        json_resp = jsonpickle.decode(responseData)
        self.assertIsNotNone(json_resp, "No results after deserialization")
        msg = json_resp.get("message", None)
        self.assertIsNotNone(msg, "No message returned")
        self.logger.info("[%s] Message: %s", method, msg)

        vulnerability_to_update = self.prepare_new_vulnerability()
        vulnerability_to_update.theName = "Edited test vulnerability"
        upd_env_body = self.prepare_json(vulnerability=vulnerability_to_update)
        rv = self.app.put(
            "/api/vulnerabilities/name/%s?session_id=test"
            % quote(self.prepare_new_vulnerability().theName),
            data=upd_env_body,
            content_type="application/json",
        )
        self.assertIsNotNone(rv.data, "No response")
        if sys.version_info > (3,):
            responseData = rv.data.decode("utf-8")
        else:
            responseData = rv.data
        json_resp = jsonpickle.decode(responseData)
        self.assertIsNotNone(json_resp)
        self.assertIsInstance(json_resp, dict)
        message = json_resp.get("message", None)
        self.assertIsNotNone(message, "No message in response")
        self.logger.info("[%s] Message: %s", method, message)
        self.assertGreater(
            message.find("updated"),
            -1,
            "The vulnerability was not successfully updated",
        )

        rv = self.app.get(
            "/api/vulnerabilities/name/%s?session_id=test"
            % quote(vulnerability_to_update.theName)
        )
        if sys.version_info > (3,):
            responseData = rv.data.decode("utf-8")
        else:
            responseData = rv.data
        upd_vulnerability = jsonpickle.decode(responseData)
        self.assertIsNotNone(upd_vulnerability, "Unable to decode JSON data")
        self.logger.debug("[%s] Response data: %s", method, responseData)
        self.logger.info(
            "[%s] Vulnerability: %s\n", method, upd_vulnerability["theName"]
        )

        rv = self.app.delete(
            "/api/vulnerabilities/name/%s?session_id=test"
            % quote(vulnerability_to_update.theName)
        )

    def prepare_new_vulnerability(self):
        new_vulnerability_prop = VulnerabilityEnvironmentProperties(
            environmentName=self.existing_environment_name,
            severity="Critical",
            assets=self.existing_asset_names,
        )

        new_vulnerability = Vulnerability(
            vulId=-1,
            vulName="Test Vulnerability",
            vulDesc="This is a test vulnerability",
            vulType="Design",
            tags=[],
            cProps=[new_vulnerability_prop],
        )

        new_vulnerability.theEnvironmentDictionary = {}

        return new_vulnerability

    def prepare_dict(self, vulnerability=None):
        if vulnerability is None:
            vulnerability = self.prepare_new_vulnerability()
        else:
            assert isinstance(vulnerability, Vulnerability)

        return {
            "session_id": "test",
            "object": vulnerability,
        }

    def prepare_json(self, data_dict=None, vulnerability=None):
        if data_dict is None:
            data_dict = self.prepare_dict(vulnerability=vulnerability)
        else:
            assert isinstance(data_dict, dict)
        new_vulnerability_body = jsonpickle.encode(data_dict)
        self.logger.info("JSON data: %s", new_vulnerability_body)
        return new_vulnerability_body
